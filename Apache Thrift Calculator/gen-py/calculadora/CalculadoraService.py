#
# Autogenerated by Thrift Compiler (0.13.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface(object):
    def sumar(self, operando1, operando2):
        """
        Parameters:
         - operando1
         - operando2

        """
        pass

    def restar(self, operando1, operando2):
        """
        Parameters:
         - operando1
         - operando2

        """
        pass

    def multiplicar(self, operando1, operando2):
        """
        Parameters:
         - operando1
         - operando2

        """
        pass

    def dividir(self, operando1, operando2):
        """
        Parameters:
         - operando1
         - operando2

        """
        pass

    def seno(self, angulo):
        """
        Parameters:
         - angulo

        """
        pass

    def coseno(self, angulo):
        """
        Parameters:
         - angulo

        """
        pass

    def tangente(self, angulo):
        """
        Parameters:
         - angulo

        """
        pass

    def gradosARadianes(self, grados):
        """
        Parameters:
         - grados

        """
        pass

    def radianesAGrados(self, radianes):
        """
        Parameters:
         - radianes

        """
        pass

    def suma_vectores(self, vector1, vector2):
        """
        Parameters:
         - vector1
         - vector2

        """
        pass

    def resta_vectores(self, vector1, vector2):
        """
        Parameters:
         - vector1
         - vector2

        """
        pass

    def producto_escalar(self, vector1, vector2):
        """
        Parameters:
         - vector1
         - vector2

        """
        pass

    def producto_vectorial(self, vector1, vector2):
        """
        Parameters:
         - vector1
         - vector2

        """
        pass

    def suma_matrices(self, matriz1, matriz2):
        """
        Parameters:
         - matriz1
         - matriz2

        """
        pass

    def resta_matrices(self, matriz1, matriz2):
        """
        Parameters:
         - matriz1
         - matriz2

        """
        pass

    def producto_matricial(self, matriz1, matriz2):
        """
        Parameters:
         - matriz1
         - matriz2

        """
        pass

    def transpuesta(self, matriz):
        """
        Parameters:
         - matriz

        """
        pass

    def inversa(self, matriz):
        """
        Parameters:
         - matriz

        """
        pass

    def determinante(self, matriz):
        """
        Parameters:
         - matriz

        """
        pass


class Client(Iface):
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def sumar(self, operando1, operando2):
        """
        Parameters:
         - operando1
         - operando2

        """
        self.send_sumar(operando1, operando2)
        return self.recv_sumar()

    def send_sumar(self, operando1, operando2):
        self._oprot.writeMessageBegin('sumar', TMessageType.CALL, self._seqid)
        args = sumar_args()
        args.operando1 = operando1
        args.operando2 = operando2
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_sumar(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = sumar_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "sumar failed: unknown result")

    def restar(self, operando1, operando2):
        """
        Parameters:
         - operando1
         - operando2

        """
        self.send_restar(operando1, operando2)
        return self.recv_restar()

    def send_restar(self, operando1, operando2):
        self._oprot.writeMessageBegin('restar', TMessageType.CALL, self._seqid)
        args = restar_args()
        args.operando1 = operando1
        args.operando2 = operando2
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_restar(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = restar_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "restar failed: unknown result")

    def multiplicar(self, operando1, operando2):
        """
        Parameters:
         - operando1
         - operando2

        """
        self.send_multiplicar(operando1, operando2)
        return self.recv_multiplicar()

    def send_multiplicar(self, operando1, operando2):
        self._oprot.writeMessageBegin('multiplicar', TMessageType.CALL, self._seqid)
        args = multiplicar_args()
        args.operando1 = operando1
        args.operando2 = operando2
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_multiplicar(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = multiplicar_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "multiplicar failed: unknown result")

    def dividir(self, operando1, operando2):
        """
        Parameters:
         - operando1
         - operando2

        """
        self.send_dividir(operando1, operando2)
        return self.recv_dividir()

    def send_dividir(self, operando1, operando2):
        self._oprot.writeMessageBegin('dividir', TMessageType.CALL, self._seqid)
        args = dividir_args()
        args.operando1 = operando1
        args.operando2 = operando2
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_dividir(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = dividir_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "dividir failed: unknown result")

    def seno(self, angulo):
        """
        Parameters:
         - angulo

        """
        self.send_seno(angulo)
        return self.recv_seno()

    def send_seno(self, angulo):
        self._oprot.writeMessageBegin('seno', TMessageType.CALL, self._seqid)
        args = seno_args()
        args.angulo = angulo
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_seno(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = seno_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "seno failed: unknown result")

    def coseno(self, angulo):
        """
        Parameters:
         - angulo

        """
        self.send_coseno(angulo)
        return self.recv_coseno()

    def send_coseno(self, angulo):
        self._oprot.writeMessageBegin('coseno', TMessageType.CALL, self._seqid)
        args = coseno_args()
        args.angulo = angulo
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_coseno(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = coseno_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "coseno failed: unknown result")

    def tangente(self, angulo):
        """
        Parameters:
         - angulo

        """
        self.send_tangente(angulo)
        return self.recv_tangente()

    def send_tangente(self, angulo):
        self._oprot.writeMessageBegin('tangente', TMessageType.CALL, self._seqid)
        args = tangente_args()
        args.angulo = angulo
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_tangente(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = tangente_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "tangente failed: unknown result")

    def gradosARadianes(self, grados):
        """
        Parameters:
         - grados

        """
        self.send_gradosARadianes(grados)
        return self.recv_gradosARadianes()

    def send_gradosARadianes(self, grados):
        self._oprot.writeMessageBegin('gradosARadianes', TMessageType.CALL, self._seqid)
        args = gradosARadianes_args()
        args.grados = grados
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_gradosARadianes(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = gradosARadianes_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "gradosARadianes failed: unknown result")

    def radianesAGrados(self, radianes):
        """
        Parameters:
         - radianes

        """
        self.send_radianesAGrados(radianes)
        return self.recv_radianesAGrados()

    def send_radianesAGrados(self, radianes):
        self._oprot.writeMessageBegin('radianesAGrados', TMessageType.CALL, self._seqid)
        args = radianesAGrados_args()
        args.radianes = radianes
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_radianesAGrados(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = radianesAGrados_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "radianesAGrados failed: unknown result")

    def suma_vectores(self, vector1, vector2):
        """
        Parameters:
         - vector1
         - vector2

        """
        self.send_suma_vectores(vector1, vector2)
        return self.recv_suma_vectores()

    def send_suma_vectores(self, vector1, vector2):
        self._oprot.writeMessageBegin('suma_vectores', TMessageType.CALL, self._seqid)
        args = suma_vectores_args()
        args.vector1 = vector1
        args.vector2 = vector2
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_suma_vectores(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = suma_vectores_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "suma_vectores failed: unknown result")

    def resta_vectores(self, vector1, vector2):
        """
        Parameters:
         - vector1
         - vector2

        """
        self.send_resta_vectores(vector1, vector2)
        return self.recv_resta_vectores()

    def send_resta_vectores(self, vector1, vector2):
        self._oprot.writeMessageBegin('resta_vectores', TMessageType.CALL, self._seqid)
        args = resta_vectores_args()
        args.vector1 = vector1
        args.vector2 = vector2
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_resta_vectores(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = resta_vectores_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "resta_vectores failed: unknown result")

    def producto_escalar(self, vector1, vector2):
        """
        Parameters:
         - vector1
         - vector2

        """
        self.send_producto_escalar(vector1, vector2)
        return self.recv_producto_escalar()

    def send_producto_escalar(self, vector1, vector2):
        self._oprot.writeMessageBegin('producto_escalar', TMessageType.CALL, self._seqid)
        args = producto_escalar_args()
        args.vector1 = vector1
        args.vector2 = vector2
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_producto_escalar(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = producto_escalar_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "producto_escalar failed: unknown result")

    def producto_vectorial(self, vector1, vector2):
        """
        Parameters:
         - vector1
         - vector2

        """
        self.send_producto_vectorial(vector1, vector2)
        return self.recv_producto_vectorial()

    def send_producto_vectorial(self, vector1, vector2):
        self._oprot.writeMessageBegin('producto_vectorial', TMessageType.CALL, self._seqid)
        args = producto_vectorial_args()
        args.vector1 = vector1
        args.vector2 = vector2
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_producto_vectorial(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = producto_vectorial_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "producto_vectorial failed: unknown result")

    def suma_matrices(self, matriz1, matriz2):
        """
        Parameters:
         - matriz1
         - matriz2

        """
        self.send_suma_matrices(matriz1, matriz2)
        return self.recv_suma_matrices()

    def send_suma_matrices(self, matriz1, matriz2):
        self._oprot.writeMessageBegin('suma_matrices', TMessageType.CALL, self._seqid)
        args = suma_matrices_args()
        args.matriz1 = matriz1
        args.matriz2 = matriz2
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_suma_matrices(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = suma_matrices_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "suma_matrices failed: unknown result")

    def resta_matrices(self, matriz1, matriz2):
        """
        Parameters:
         - matriz1
         - matriz2

        """
        self.send_resta_matrices(matriz1, matriz2)
        return self.recv_resta_matrices()

    def send_resta_matrices(self, matriz1, matriz2):
        self._oprot.writeMessageBegin('resta_matrices', TMessageType.CALL, self._seqid)
        args = resta_matrices_args()
        args.matriz1 = matriz1
        args.matriz2 = matriz2
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_resta_matrices(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = resta_matrices_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "resta_matrices failed: unknown result")

    def producto_matricial(self, matriz1, matriz2):
        """
        Parameters:
         - matriz1
         - matriz2

        """
        self.send_producto_matricial(matriz1, matriz2)
        return self.recv_producto_matricial()

    def send_producto_matricial(self, matriz1, matriz2):
        self._oprot.writeMessageBegin('producto_matricial', TMessageType.CALL, self._seqid)
        args = producto_matricial_args()
        args.matriz1 = matriz1
        args.matriz2 = matriz2
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_producto_matricial(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = producto_matricial_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "producto_matricial failed: unknown result")

    def transpuesta(self, matriz):
        """
        Parameters:
         - matriz

        """
        self.send_transpuesta(matriz)
        return self.recv_transpuesta()

    def send_transpuesta(self, matriz):
        self._oprot.writeMessageBegin('transpuesta', TMessageType.CALL, self._seqid)
        args = transpuesta_args()
        args.matriz = matriz
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_transpuesta(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = transpuesta_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "transpuesta failed: unknown result")

    def inversa(self, matriz):
        """
        Parameters:
         - matriz

        """
        self.send_inversa(matriz)
        return self.recv_inversa()

    def send_inversa(self, matriz):
        self._oprot.writeMessageBegin('inversa', TMessageType.CALL, self._seqid)
        args = inversa_args()
        args.matriz = matriz
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_inversa(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = inversa_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "inversa failed: unknown result")

    def determinante(self, matriz):
        """
        Parameters:
         - matriz

        """
        self.send_determinante(matriz)
        return self.recv_determinante()

    def send_determinante(self, matriz):
        self._oprot.writeMessageBegin('determinante', TMessageType.CALL, self._seqid)
        args = determinante_args()
        args.matriz = matriz
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_determinante(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = determinante_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "determinante failed: unknown result")


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["sumar"] = Processor.process_sumar
        self._processMap["restar"] = Processor.process_restar
        self._processMap["multiplicar"] = Processor.process_multiplicar
        self._processMap["dividir"] = Processor.process_dividir
        self._processMap["seno"] = Processor.process_seno
        self._processMap["coseno"] = Processor.process_coseno
        self._processMap["tangente"] = Processor.process_tangente
        self._processMap["gradosARadianes"] = Processor.process_gradosARadianes
        self._processMap["radianesAGrados"] = Processor.process_radianesAGrados
        self._processMap["suma_vectores"] = Processor.process_suma_vectores
        self._processMap["resta_vectores"] = Processor.process_resta_vectores
        self._processMap["producto_escalar"] = Processor.process_producto_escalar
        self._processMap["producto_vectorial"] = Processor.process_producto_vectorial
        self._processMap["suma_matrices"] = Processor.process_suma_matrices
        self._processMap["resta_matrices"] = Processor.process_resta_matrices
        self._processMap["producto_matricial"] = Processor.process_producto_matricial
        self._processMap["transpuesta"] = Processor.process_transpuesta
        self._processMap["inversa"] = Processor.process_inversa
        self._processMap["determinante"] = Processor.process_determinante
        self._on_message_begin = None

    def on_message_begin(self, func):
        self._on_message_begin = func

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if self._on_message_begin:
            self._on_message_begin(name, type, seqid)
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_sumar(self, seqid, iprot, oprot):
        args = sumar_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = sumar_result()
        try:
            result.success = self._handler.sumar(args.operando1, args.operando2)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("sumar", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_restar(self, seqid, iprot, oprot):
        args = restar_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = restar_result()
        try:
            result.success = self._handler.restar(args.operando1, args.operando2)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("restar", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_multiplicar(self, seqid, iprot, oprot):
        args = multiplicar_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = multiplicar_result()
        try:
            result.success = self._handler.multiplicar(args.operando1, args.operando2)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("multiplicar", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_dividir(self, seqid, iprot, oprot):
        args = dividir_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = dividir_result()
        try:
            result.success = self._handler.dividir(args.operando1, args.operando2)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("dividir", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_seno(self, seqid, iprot, oprot):
        args = seno_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = seno_result()
        try:
            result.success = self._handler.seno(args.angulo)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("seno", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_coseno(self, seqid, iprot, oprot):
        args = coseno_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = coseno_result()
        try:
            result.success = self._handler.coseno(args.angulo)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("coseno", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_tangente(self, seqid, iprot, oprot):
        args = tangente_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = tangente_result()
        try:
            result.success = self._handler.tangente(args.angulo)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("tangente", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_gradosARadianes(self, seqid, iprot, oprot):
        args = gradosARadianes_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = gradosARadianes_result()
        try:
            result.success = self._handler.gradosARadianes(args.grados)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("gradosARadianes", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_radianesAGrados(self, seqid, iprot, oprot):
        args = radianesAGrados_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = radianesAGrados_result()
        try:
            result.success = self._handler.radianesAGrados(args.radianes)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("radianesAGrados", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_suma_vectores(self, seqid, iprot, oprot):
        args = suma_vectores_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = suma_vectores_result()
        try:
            result.success = self._handler.suma_vectores(args.vector1, args.vector2)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("suma_vectores", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_resta_vectores(self, seqid, iprot, oprot):
        args = resta_vectores_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = resta_vectores_result()
        try:
            result.success = self._handler.resta_vectores(args.vector1, args.vector2)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("resta_vectores", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_producto_escalar(self, seqid, iprot, oprot):
        args = producto_escalar_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = producto_escalar_result()
        try:
            result.success = self._handler.producto_escalar(args.vector1, args.vector2)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("producto_escalar", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_producto_vectorial(self, seqid, iprot, oprot):
        args = producto_vectorial_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = producto_vectorial_result()
        try:
            result.success = self._handler.producto_vectorial(args.vector1, args.vector2)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("producto_vectorial", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_suma_matrices(self, seqid, iprot, oprot):
        args = suma_matrices_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = suma_matrices_result()
        try:
            result.success = self._handler.suma_matrices(args.matriz1, args.matriz2)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("suma_matrices", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_resta_matrices(self, seqid, iprot, oprot):
        args = resta_matrices_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = resta_matrices_result()
        try:
            result.success = self._handler.resta_matrices(args.matriz1, args.matriz2)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("resta_matrices", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_producto_matricial(self, seqid, iprot, oprot):
        args = producto_matricial_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = producto_matricial_result()
        try:
            result.success = self._handler.producto_matricial(args.matriz1, args.matriz2)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("producto_matricial", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_transpuesta(self, seqid, iprot, oprot):
        args = transpuesta_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = transpuesta_result()
        try:
            result.success = self._handler.transpuesta(args.matriz)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("transpuesta", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_inversa(self, seqid, iprot, oprot):
        args = inversa_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = inversa_result()
        try:
            result.success = self._handler.inversa(args.matriz)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("inversa", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_determinante(self, seqid, iprot, oprot):
        args = determinante_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = determinante_result()
        try:
            result.success = self._handler.determinante(args.matriz)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("determinante", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class sumar_args(object):
    """
    Attributes:
     - operando1
     - operando2

    """


    def __init__(self, operando1=None, operando2=None,):
        self.operando1 = operando1
        self.operando2 = operando2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.operando1 = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.operando2 = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('sumar_args')
        if self.operando1 is not None:
            oprot.writeFieldBegin('operando1', TType.DOUBLE, 1)
            oprot.writeDouble(self.operando1)
            oprot.writeFieldEnd()
        if self.operando2 is not None:
            oprot.writeFieldBegin('operando2', TType.DOUBLE, 2)
            oprot.writeDouble(self.operando2)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(sumar_args)
sumar_args.thrift_spec = (
    None,  # 0
    (1, TType.DOUBLE, 'operando1', None, None, ),  # 1
    (2, TType.DOUBLE, 'operando2', None, None, ),  # 2
)


class sumar_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.DOUBLE:
                    self.success = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('sumar_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.DOUBLE, 0)
            oprot.writeDouble(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(sumar_result)
sumar_result.thrift_spec = (
    (0, TType.DOUBLE, 'success', None, None, ),  # 0
)


class restar_args(object):
    """
    Attributes:
     - operando1
     - operando2

    """


    def __init__(self, operando1=None, operando2=None,):
        self.operando1 = operando1
        self.operando2 = operando2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.operando1 = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.operando2 = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('restar_args')
        if self.operando1 is not None:
            oprot.writeFieldBegin('operando1', TType.DOUBLE, 1)
            oprot.writeDouble(self.operando1)
            oprot.writeFieldEnd()
        if self.operando2 is not None:
            oprot.writeFieldBegin('operando2', TType.DOUBLE, 2)
            oprot.writeDouble(self.operando2)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(restar_args)
restar_args.thrift_spec = (
    None,  # 0
    (1, TType.DOUBLE, 'operando1', None, None, ),  # 1
    (2, TType.DOUBLE, 'operando2', None, None, ),  # 2
)


class restar_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.DOUBLE:
                    self.success = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('restar_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.DOUBLE, 0)
            oprot.writeDouble(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(restar_result)
restar_result.thrift_spec = (
    (0, TType.DOUBLE, 'success', None, None, ),  # 0
)


class multiplicar_args(object):
    """
    Attributes:
     - operando1
     - operando2

    """


    def __init__(self, operando1=None, operando2=None,):
        self.operando1 = operando1
        self.operando2 = operando2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.operando1 = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.operando2 = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('multiplicar_args')
        if self.operando1 is not None:
            oprot.writeFieldBegin('operando1', TType.DOUBLE, 1)
            oprot.writeDouble(self.operando1)
            oprot.writeFieldEnd()
        if self.operando2 is not None:
            oprot.writeFieldBegin('operando2', TType.DOUBLE, 2)
            oprot.writeDouble(self.operando2)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(multiplicar_args)
multiplicar_args.thrift_spec = (
    None,  # 0
    (1, TType.DOUBLE, 'operando1', None, None, ),  # 1
    (2, TType.DOUBLE, 'operando2', None, None, ),  # 2
)


class multiplicar_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.DOUBLE:
                    self.success = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('multiplicar_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.DOUBLE, 0)
            oprot.writeDouble(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(multiplicar_result)
multiplicar_result.thrift_spec = (
    (0, TType.DOUBLE, 'success', None, None, ),  # 0
)


class dividir_args(object):
    """
    Attributes:
     - operando1
     - operando2

    """


    def __init__(self, operando1=None, operando2=None,):
        self.operando1 = operando1
        self.operando2 = operando2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.operando1 = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.operando2 = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dividir_args')
        if self.operando1 is not None:
            oprot.writeFieldBegin('operando1', TType.DOUBLE, 1)
            oprot.writeDouble(self.operando1)
            oprot.writeFieldEnd()
        if self.operando2 is not None:
            oprot.writeFieldBegin('operando2', TType.DOUBLE, 2)
            oprot.writeDouble(self.operando2)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dividir_args)
dividir_args.thrift_spec = (
    None,  # 0
    (1, TType.DOUBLE, 'operando1', None, None, ),  # 1
    (2, TType.DOUBLE, 'operando2', None, None, ),  # 2
)


class dividir_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.DOUBLE:
                    self.success = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dividir_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.DOUBLE, 0)
            oprot.writeDouble(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dividir_result)
dividir_result.thrift_spec = (
    (0, TType.DOUBLE, 'success', None, None, ),  # 0
)


class seno_args(object):
    """
    Attributes:
     - angulo

    """


    def __init__(self, angulo=None,):
        self.angulo = angulo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.angulo = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('seno_args')
        if self.angulo is not None:
            oprot.writeFieldBegin('angulo', TType.DOUBLE, 1)
            oprot.writeDouble(self.angulo)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(seno_args)
seno_args.thrift_spec = (
    None,  # 0
    (1, TType.DOUBLE, 'angulo', None, None, ),  # 1
)


class seno_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.DOUBLE:
                    self.success = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('seno_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.DOUBLE, 0)
            oprot.writeDouble(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(seno_result)
seno_result.thrift_spec = (
    (0, TType.DOUBLE, 'success', None, None, ),  # 0
)


class coseno_args(object):
    """
    Attributes:
     - angulo

    """


    def __init__(self, angulo=None,):
        self.angulo = angulo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.angulo = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('coseno_args')
        if self.angulo is not None:
            oprot.writeFieldBegin('angulo', TType.DOUBLE, 1)
            oprot.writeDouble(self.angulo)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(coseno_args)
coseno_args.thrift_spec = (
    None,  # 0
    (1, TType.DOUBLE, 'angulo', None, None, ),  # 1
)


class coseno_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.DOUBLE:
                    self.success = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('coseno_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.DOUBLE, 0)
            oprot.writeDouble(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(coseno_result)
coseno_result.thrift_spec = (
    (0, TType.DOUBLE, 'success', None, None, ),  # 0
)


class tangente_args(object):
    """
    Attributes:
     - angulo

    """


    def __init__(self, angulo=None,):
        self.angulo = angulo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.angulo = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tangente_args')
        if self.angulo is not None:
            oprot.writeFieldBegin('angulo', TType.DOUBLE, 1)
            oprot.writeDouble(self.angulo)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tangente_args)
tangente_args.thrift_spec = (
    None,  # 0
    (1, TType.DOUBLE, 'angulo', None, None, ),  # 1
)


class tangente_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.DOUBLE:
                    self.success = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tangente_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.DOUBLE, 0)
            oprot.writeDouble(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tangente_result)
tangente_result.thrift_spec = (
    (0, TType.DOUBLE, 'success', None, None, ),  # 0
)


class gradosARadianes_args(object):
    """
    Attributes:
     - grados

    """


    def __init__(self, grados=None,):
        self.grados = grados

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.grados = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('gradosARadianes_args')
        if self.grados is not None:
            oprot.writeFieldBegin('grados', TType.DOUBLE, 1)
            oprot.writeDouble(self.grados)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(gradosARadianes_args)
gradosARadianes_args.thrift_spec = (
    None,  # 0
    (1, TType.DOUBLE, 'grados', None, None, ),  # 1
)


class gradosARadianes_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.DOUBLE:
                    self.success = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('gradosARadianes_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.DOUBLE, 0)
            oprot.writeDouble(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(gradosARadianes_result)
gradosARadianes_result.thrift_spec = (
    (0, TType.DOUBLE, 'success', None, None, ),  # 0
)


class radianesAGrados_args(object):
    """
    Attributes:
     - radianes

    """


    def __init__(self, radianes=None,):
        self.radianes = radianes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.radianes = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('radianesAGrados_args')
        if self.radianes is not None:
            oprot.writeFieldBegin('radianes', TType.DOUBLE, 1)
            oprot.writeDouble(self.radianes)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(radianesAGrados_args)
radianesAGrados_args.thrift_spec = (
    None,  # 0
    (1, TType.DOUBLE, 'radianes', None, None, ),  # 1
)


class radianesAGrados_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.DOUBLE:
                    self.success = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('radianesAGrados_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.DOUBLE, 0)
            oprot.writeDouble(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(radianesAGrados_result)
radianesAGrados_result.thrift_spec = (
    (0, TType.DOUBLE, 'success', None, None, ),  # 0
)


class suma_vectores_args(object):
    """
    Attributes:
     - vector1
     - vector2

    """


    def __init__(self, vector1=None, vector2=None,):
        self.vector1 = vector1
        self.vector2 = vector2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.vector1 = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = iprot.readDouble()
                        self.vector1.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.vector2 = []
                    (_etype9, _size6) = iprot.readListBegin()
                    for _i10 in range(_size6):
                        _elem11 = iprot.readDouble()
                        self.vector2.append(_elem11)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('suma_vectores_args')
        if self.vector1 is not None:
            oprot.writeFieldBegin('vector1', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.vector1))
            for iter12 in self.vector1:
                oprot.writeDouble(iter12)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.vector2 is not None:
            oprot.writeFieldBegin('vector2', TType.LIST, 2)
            oprot.writeListBegin(TType.DOUBLE, len(self.vector2))
            for iter13 in self.vector2:
                oprot.writeDouble(iter13)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(suma_vectores_args)
suma_vectores_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'vector1', (TType.DOUBLE, None, False), None, ),  # 1
    (2, TType.LIST, 'vector2', (TType.DOUBLE, None, False), None, ),  # 2
)


class suma_vectores_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype17, _size14) = iprot.readListBegin()
                    for _i18 in range(_size14):
                        _elem19 = iprot.readDouble()
                        self.success.append(_elem19)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('suma_vectores_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.DOUBLE, len(self.success))
            for iter20 in self.success:
                oprot.writeDouble(iter20)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(suma_vectores_result)
suma_vectores_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.DOUBLE, None, False), None, ),  # 0
)


class resta_vectores_args(object):
    """
    Attributes:
     - vector1
     - vector2

    """


    def __init__(self, vector1=None, vector2=None,):
        self.vector1 = vector1
        self.vector2 = vector2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.vector1 = []
                    (_etype24, _size21) = iprot.readListBegin()
                    for _i25 in range(_size21):
                        _elem26 = iprot.readDouble()
                        self.vector1.append(_elem26)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.vector2 = []
                    (_etype30, _size27) = iprot.readListBegin()
                    for _i31 in range(_size27):
                        _elem32 = iprot.readDouble()
                        self.vector2.append(_elem32)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('resta_vectores_args')
        if self.vector1 is not None:
            oprot.writeFieldBegin('vector1', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.vector1))
            for iter33 in self.vector1:
                oprot.writeDouble(iter33)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.vector2 is not None:
            oprot.writeFieldBegin('vector2', TType.LIST, 2)
            oprot.writeListBegin(TType.DOUBLE, len(self.vector2))
            for iter34 in self.vector2:
                oprot.writeDouble(iter34)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(resta_vectores_args)
resta_vectores_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'vector1', (TType.DOUBLE, None, False), None, ),  # 1
    (2, TType.LIST, 'vector2', (TType.DOUBLE, None, False), None, ),  # 2
)


class resta_vectores_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype38, _size35) = iprot.readListBegin()
                    for _i39 in range(_size35):
                        _elem40 = iprot.readDouble()
                        self.success.append(_elem40)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('resta_vectores_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.DOUBLE, len(self.success))
            for iter41 in self.success:
                oprot.writeDouble(iter41)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(resta_vectores_result)
resta_vectores_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.DOUBLE, None, False), None, ),  # 0
)


class producto_escalar_args(object):
    """
    Attributes:
     - vector1
     - vector2

    """


    def __init__(self, vector1=None, vector2=None,):
        self.vector1 = vector1
        self.vector2 = vector2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.vector1 = []
                    (_etype45, _size42) = iprot.readListBegin()
                    for _i46 in range(_size42):
                        _elem47 = iprot.readDouble()
                        self.vector1.append(_elem47)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.vector2 = []
                    (_etype51, _size48) = iprot.readListBegin()
                    for _i52 in range(_size48):
                        _elem53 = iprot.readDouble()
                        self.vector2.append(_elem53)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('producto_escalar_args')
        if self.vector1 is not None:
            oprot.writeFieldBegin('vector1', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.vector1))
            for iter54 in self.vector1:
                oprot.writeDouble(iter54)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.vector2 is not None:
            oprot.writeFieldBegin('vector2', TType.LIST, 2)
            oprot.writeListBegin(TType.DOUBLE, len(self.vector2))
            for iter55 in self.vector2:
                oprot.writeDouble(iter55)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(producto_escalar_args)
producto_escalar_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'vector1', (TType.DOUBLE, None, False), None, ),  # 1
    (2, TType.LIST, 'vector2', (TType.DOUBLE, None, False), None, ),  # 2
)


class producto_escalar_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.DOUBLE:
                    self.success = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('producto_escalar_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.DOUBLE, 0)
            oprot.writeDouble(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(producto_escalar_result)
producto_escalar_result.thrift_spec = (
    (0, TType.DOUBLE, 'success', None, None, ),  # 0
)


class producto_vectorial_args(object):
    """
    Attributes:
     - vector1
     - vector2

    """


    def __init__(self, vector1=None, vector2=None,):
        self.vector1 = vector1
        self.vector2 = vector2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.vector1 = []
                    (_etype59, _size56) = iprot.readListBegin()
                    for _i60 in range(_size56):
                        _elem61 = iprot.readDouble()
                        self.vector1.append(_elem61)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.vector2 = []
                    (_etype65, _size62) = iprot.readListBegin()
                    for _i66 in range(_size62):
                        _elem67 = iprot.readDouble()
                        self.vector2.append(_elem67)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('producto_vectorial_args')
        if self.vector1 is not None:
            oprot.writeFieldBegin('vector1', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.vector1))
            for iter68 in self.vector1:
                oprot.writeDouble(iter68)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.vector2 is not None:
            oprot.writeFieldBegin('vector2', TType.LIST, 2)
            oprot.writeListBegin(TType.DOUBLE, len(self.vector2))
            for iter69 in self.vector2:
                oprot.writeDouble(iter69)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(producto_vectorial_args)
producto_vectorial_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'vector1', (TType.DOUBLE, None, False), None, ),  # 1
    (2, TType.LIST, 'vector2', (TType.DOUBLE, None, False), None, ),  # 2
)


class producto_vectorial_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype73, _size70) = iprot.readListBegin()
                    for _i74 in range(_size70):
                        _elem75 = iprot.readDouble()
                        self.success.append(_elem75)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('producto_vectorial_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.DOUBLE, len(self.success))
            for iter76 in self.success:
                oprot.writeDouble(iter76)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(producto_vectorial_result)
producto_vectorial_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.DOUBLE, None, False), None, ),  # 0
)


class suma_matrices_args(object):
    """
    Attributes:
     - matriz1
     - matriz2

    """


    def __init__(self, matriz1=None, matriz2=None,):
        self.matriz1 = matriz1
        self.matriz2 = matriz2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.matriz1 = []
                    (_etype80, _size77) = iprot.readListBegin()
                    for _i81 in range(_size77):
                        _elem82 = []
                        (_etype86, _size83) = iprot.readListBegin()
                        for _i87 in range(_size83):
                            _elem88 = iprot.readDouble()
                            _elem82.append(_elem88)
                        iprot.readListEnd()
                        self.matriz1.append(_elem82)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.matriz2 = []
                    (_etype92, _size89) = iprot.readListBegin()
                    for _i93 in range(_size89):
                        _elem94 = []
                        (_etype98, _size95) = iprot.readListBegin()
                        for _i99 in range(_size95):
                            _elem100 = iprot.readDouble()
                            _elem94.append(_elem100)
                        iprot.readListEnd()
                        self.matriz2.append(_elem94)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('suma_matrices_args')
        if self.matriz1 is not None:
            oprot.writeFieldBegin('matriz1', TType.LIST, 1)
            oprot.writeListBegin(TType.LIST, len(self.matriz1))
            for iter101 in self.matriz1:
                oprot.writeListBegin(TType.DOUBLE, len(iter101))
                for iter102 in iter101:
                    oprot.writeDouble(iter102)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.matriz2 is not None:
            oprot.writeFieldBegin('matriz2', TType.LIST, 2)
            oprot.writeListBegin(TType.LIST, len(self.matriz2))
            for iter103 in self.matriz2:
                oprot.writeListBegin(TType.DOUBLE, len(iter103))
                for iter104 in iter103:
                    oprot.writeDouble(iter104)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(suma_matrices_args)
suma_matrices_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'matriz1', (TType.LIST, (TType.DOUBLE, None, False), False), None, ),  # 1
    (2, TType.LIST, 'matriz2', (TType.LIST, (TType.DOUBLE, None, False), False), None, ),  # 2
)


class suma_matrices_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype108, _size105) = iprot.readListBegin()
                    for _i109 in range(_size105):
                        _elem110 = []
                        (_etype114, _size111) = iprot.readListBegin()
                        for _i115 in range(_size111):
                            _elem116 = iprot.readDouble()
                            _elem110.append(_elem116)
                        iprot.readListEnd()
                        self.success.append(_elem110)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('suma_matrices_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.LIST, len(self.success))
            for iter117 in self.success:
                oprot.writeListBegin(TType.DOUBLE, len(iter117))
                for iter118 in iter117:
                    oprot.writeDouble(iter118)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(suma_matrices_result)
suma_matrices_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.LIST, (TType.DOUBLE, None, False), False), None, ),  # 0
)


class resta_matrices_args(object):
    """
    Attributes:
     - matriz1
     - matriz2

    """


    def __init__(self, matriz1=None, matriz2=None,):
        self.matriz1 = matriz1
        self.matriz2 = matriz2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.matriz1 = []
                    (_etype122, _size119) = iprot.readListBegin()
                    for _i123 in range(_size119):
                        _elem124 = []
                        (_etype128, _size125) = iprot.readListBegin()
                        for _i129 in range(_size125):
                            _elem130 = iprot.readDouble()
                            _elem124.append(_elem130)
                        iprot.readListEnd()
                        self.matriz1.append(_elem124)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.matriz2 = []
                    (_etype134, _size131) = iprot.readListBegin()
                    for _i135 in range(_size131):
                        _elem136 = []
                        (_etype140, _size137) = iprot.readListBegin()
                        for _i141 in range(_size137):
                            _elem142 = iprot.readDouble()
                            _elem136.append(_elem142)
                        iprot.readListEnd()
                        self.matriz2.append(_elem136)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('resta_matrices_args')
        if self.matriz1 is not None:
            oprot.writeFieldBegin('matriz1', TType.LIST, 1)
            oprot.writeListBegin(TType.LIST, len(self.matriz1))
            for iter143 in self.matriz1:
                oprot.writeListBegin(TType.DOUBLE, len(iter143))
                for iter144 in iter143:
                    oprot.writeDouble(iter144)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.matriz2 is not None:
            oprot.writeFieldBegin('matriz2', TType.LIST, 2)
            oprot.writeListBegin(TType.LIST, len(self.matriz2))
            for iter145 in self.matriz2:
                oprot.writeListBegin(TType.DOUBLE, len(iter145))
                for iter146 in iter145:
                    oprot.writeDouble(iter146)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(resta_matrices_args)
resta_matrices_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'matriz1', (TType.LIST, (TType.DOUBLE, None, False), False), None, ),  # 1
    (2, TType.LIST, 'matriz2', (TType.LIST, (TType.DOUBLE, None, False), False), None, ),  # 2
)


class resta_matrices_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype150, _size147) = iprot.readListBegin()
                    for _i151 in range(_size147):
                        _elem152 = []
                        (_etype156, _size153) = iprot.readListBegin()
                        for _i157 in range(_size153):
                            _elem158 = iprot.readDouble()
                            _elem152.append(_elem158)
                        iprot.readListEnd()
                        self.success.append(_elem152)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('resta_matrices_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.LIST, len(self.success))
            for iter159 in self.success:
                oprot.writeListBegin(TType.DOUBLE, len(iter159))
                for iter160 in iter159:
                    oprot.writeDouble(iter160)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(resta_matrices_result)
resta_matrices_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.LIST, (TType.DOUBLE, None, False), False), None, ),  # 0
)


class producto_matricial_args(object):
    """
    Attributes:
     - matriz1
     - matriz2

    """


    def __init__(self, matriz1=None, matriz2=None,):
        self.matriz1 = matriz1
        self.matriz2 = matriz2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.matriz1 = []
                    (_etype164, _size161) = iprot.readListBegin()
                    for _i165 in range(_size161):
                        _elem166 = []
                        (_etype170, _size167) = iprot.readListBegin()
                        for _i171 in range(_size167):
                            _elem172 = iprot.readDouble()
                            _elem166.append(_elem172)
                        iprot.readListEnd()
                        self.matriz1.append(_elem166)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.matriz2 = []
                    (_etype176, _size173) = iprot.readListBegin()
                    for _i177 in range(_size173):
                        _elem178 = []
                        (_etype182, _size179) = iprot.readListBegin()
                        for _i183 in range(_size179):
                            _elem184 = iprot.readDouble()
                            _elem178.append(_elem184)
                        iprot.readListEnd()
                        self.matriz2.append(_elem178)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('producto_matricial_args')
        if self.matriz1 is not None:
            oprot.writeFieldBegin('matriz1', TType.LIST, 1)
            oprot.writeListBegin(TType.LIST, len(self.matriz1))
            for iter185 in self.matriz1:
                oprot.writeListBegin(TType.DOUBLE, len(iter185))
                for iter186 in iter185:
                    oprot.writeDouble(iter186)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.matriz2 is not None:
            oprot.writeFieldBegin('matriz2', TType.LIST, 2)
            oprot.writeListBegin(TType.LIST, len(self.matriz2))
            for iter187 in self.matriz2:
                oprot.writeListBegin(TType.DOUBLE, len(iter187))
                for iter188 in iter187:
                    oprot.writeDouble(iter188)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(producto_matricial_args)
producto_matricial_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'matriz1', (TType.LIST, (TType.DOUBLE, None, False), False), None, ),  # 1
    (2, TType.LIST, 'matriz2', (TType.LIST, (TType.DOUBLE, None, False), False), None, ),  # 2
)


class producto_matricial_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype192, _size189) = iprot.readListBegin()
                    for _i193 in range(_size189):
                        _elem194 = []
                        (_etype198, _size195) = iprot.readListBegin()
                        for _i199 in range(_size195):
                            _elem200 = iprot.readDouble()
                            _elem194.append(_elem200)
                        iprot.readListEnd()
                        self.success.append(_elem194)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('producto_matricial_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.LIST, len(self.success))
            for iter201 in self.success:
                oprot.writeListBegin(TType.DOUBLE, len(iter201))
                for iter202 in iter201:
                    oprot.writeDouble(iter202)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(producto_matricial_result)
producto_matricial_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.LIST, (TType.DOUBLE, None, False), False), None, ),  # 0
)


class transpuesta_args(object):
    """
    Attributes:
     - matriz

    """


    def __init__(self, matriz=None,):
        self.matriz = matriz

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.matriz = []
                    (_etype206, _size203) = iprot.readListBegin()
                    for _i207 in range(_size203):
                        _elem208 = []
                        (_etype212, _size209) = iprot.readListBegin()
                        for _i213 in range(_size209):
                            _elem214 = iprot.readDouble()
                            _elem208.append(_elem214)
                        iprot.readListEnd()
                        self.matriz.append(_elem208)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('transpuesta_args')
        if self.matriz is not None:
            oprot.writeFieldBegin('matriz', TType.LIST, 1)
            oprot.writeListBegin(TType.LIST, len(self.matriz))
            for iter215 in self.matriz:
                oprot.writeListBegin(TType.DOUBLE, len(iter215))
                for iter216 in iter215:
                    oprot.writeDouble(iter216)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(transpuesta_args)
transpuesta_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'matriz', (TType.LIST, (TType.DOUBLE, None, False), False), None, ),  # 1
)


class transpuesta_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype220, _size217) = iprot.readListBegin()
                    for _i221 in range(_size217):
                        _elem222 = []
                        (_etype226, _size223) = iprot.readListBegin()
                        for _i227 in range(_size223):
                            _elem228 = iprot.readDouble()
                            _elem222.append(_elem228)
                        iprot.readListEnd()
                        self.success.append(_elem222)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('transpuesta_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.LIST, len(self.success))
            for iter229 in self.success:
                oprot.writeListBegin(TType.DOUBLE, len(iter229))
                for iter230 in iter229:
                    oprot.writeDouble(iter230)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(transpuesta_result)
transpuesta_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.LIST, (TType.DOUBLE, None, False), False), None, ),  # 0
)


class inversa_args(object):
    """
    Attributes:
     - matriz

    """


    def __init__(self, matriz=None,):
        self.matriz = matriz

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.matriz = []
                    (_etype234, _size231) = iprot.readListBegin()
                    for _i235 in range(_size231):
                        _elem236 = []
                        (_etype240, _size237) = iprot.readListBegin()
                        for _i241 in range(_size237):
                            _elem242 = iprot.readDouble()
                            _elem236.append(_elem242)
                        iprot.readListEnd()
                        self.matriz.append(_elem236)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('inversa_args')
        if self.matriz is not None:
            oprot.writeFieldBegin('matriz', TType.LIST, 1)
            oprot.writeListBegin(TType.LIST, len(self.matriz))
            for iter243 in self.matriz:
                oprot.writeListBegin(TType.DOUBLE, len(iter243))
                for iter244 in iter243:
                    oprot.writeDouble(iter244)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(inversa_args)
inversa_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'matriz', (TType.LIST, (TType.DOUBLE, None, False), False), None, ),  # 1
)


class inversa_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype248, _size245) = iprot.readListBegin()
                    for _i249 in range(_size245):
                        _elem250 = []
                        (_etype254, _size251) = iprot.readListBegin()
                        for _i255 in range(_size251):
                            _elem256 = iprot.readDouble()
                            _elem250.append(_elem256)
                        iprot.readListEnd()
                        self.success.append(_elem250)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('inversa_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.LIST, len(self.success))
            for iter257 in self.success:
                oprot.writeListBegin(TType.DOUBLE, len(iter257))
                for iter258 in iter257:
                    oprot.writeDouble(iter258)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(inversa_result)
inversa_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.LIST, (TType.DOUBLE, None, False), False), None, ),  # 0
)


class determinante_args(object):
    """
    Attributes:
     - matriz

    """


    def __init__(self, matriz=None,):
        self.matriz = matriz

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.matriz = []
                    (_etype262, _size259) = iprot.readListBegin()
                    for _i263 in range(_size259):
                        _elem264 = []
                        (_etype268, _size265) = iprot.readListBegin()
                        for _i269 in range(_size265):
                            _elem270 = iprot.readDouble()
                            _elem264.append(_elem270)
                        iprot.readListEnd()
                        self.matriz.append(_elem264)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('determinante_args')
        if self.matriz is not None:
            oprot.writeFieldBegin('matriz', TType.LIST, 1)
            oprot.writeListBegin(TType.LIST, len(self.matriz))
            for iter271 in self.matriz:
                oprot.writeListBegin(TType.DOUBLE, len(iter271))
                for iter272 in iter271:
                    oprot.writeDouble(iter272)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(determinante_args)
determinante_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'matriz', (TType.LIST, (TType.DOUBLE, None, False), False), None, ),  # 1
)


class determinante_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.DOUBLE:
                    self.success = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('determinante_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.DOUBLE, 0)
            oprot.writeDouble(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(determinante_result)
determinante_result.thrift_spec = (
    (0, TType.DOUBLE, 'success', None, None, ),  # 0
)
fix_spec(all_structs)
del all_structs

